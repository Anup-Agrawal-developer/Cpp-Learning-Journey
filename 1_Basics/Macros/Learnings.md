
Macros in C++ :-

Macros is preprocessor to keep unique name for constant values.

And During compilation,
   At preprocessor stage,

Total code which is written with or started with '#' will be replaced with actual value and later on
assemebly code will be created and that code will be converted into objects files for each .cpp files.
And at linking stage,
All .o files and static/shared libraries will be linked
Finally Exxecutable file will be generated by compiler.

Visual Compilation Flow of cpp files

Source Code (.cpp)
        │
        ▼
Preprocessing (cpp) → Generates **.i** file. [Not Created by Default]**
        │
        ▼
Compilation (g++ -S) → Generates **.s** (Assembly file) [Not Created by Default]**
        │
        ▼
Assembly (as) → Generates **.o** (Object file) [Created]**
        │
        ▼
Linker (ld) → Generates **Executable (a.out or program.exe or executable filename without extension)** [Created]**


If you want to create all files like .i .s as well. Then you add compilation flag called
commonly we can use {-save-temps}


But, specifically,

Preprocessor  ==>  g++ -E test.cpp -o test.i   ===> test.i [preprocessor code]
Compilation   ==>  g++ -S test.cpp -o test.s   ===> test.s [assembly code]
Assembly      ==>  g++ -c test.cpp -o test.o   ===> test.o [object code]
Linking       ==>  g++ test.o -o test          ===> test   [executable file]


So, preprocessor directly replaces each code which is started with "#" at preprocessor stage.

E.g.
```
#define MAIN 4

int main()
{
    int a = MAIN;

    int b = MAIN;

    cout<<"default value = "<<MAIN<<endl;

}
```
if you compile above code and check .i file it will look like below,

```
int main()
{
    int a = 4;
    
    int b = 4;

    cout<<"default value = "<<4<<endl;
}
```

It is kinda similar const keyword variables. But, const keyword are not replace with actual values they will occupy specific memory for each variable. And get value from stack of that respective variable.

Even you can keep macros for any kinds c++ syntax as well. But, that is correct way or use of macros.

I can create even macro functions which will make code more readable.

E.g.

```
#define LOG(x) cout<<x<<endl<<endl

/*
Or can be written in this way which is more understandable,

#define LOG(x)           \
{                        \
    cout<<x<<endl<<endl; \
}

But, need to add backward slash to add each new line
*/

void Macros()
{
    // cout<<"Macros [START]"<<endl<<endl;
    LOG("Macros [START]");

    //cout<<"Macros [END]"<<endl<<endl;
    LOG("Macros [END]");
}
```

This way, code gets more readable. As i shown you have 2 ways to define your function. 
But, in first way, you can't specify semicolon at the end of statement. Because macro will add ; as well.

Uses of Macros :-

- Macro names are always defined with Capital letters totally as this normal coding format for developers to understand it as Macro.
- Macros are used nomrally for any kind of constant values. So, by macro name it can be easily understandable.


There are some predefined macros also which you can use for debugging like,
__FILE__   ==> which gives FILE name means your .cpp filename
__LINE__   ==> gives line number where you written this Macro.
__func__   ==> Gives function name

```
#define LOG(x) cout<<__FILE__<<":"<<__LINE__<<" "<<__func__<<"() "<<x<<endl<<endl

void Macros()
{
    LOG("[START]");

    LOG("[END]");
}
```

```
o/p :
Macros/src/DLLs/Macros/Macros.cpp:20 Macros() [START]

Macros/src/DLLs/Macros/Macros.cpp:29 Macros() [END]

```

One more example of macro function calculator which confuse users about calculations.


```
int calculate(int a, int b, int c)
{
    return a + b * c;
}

#define CALCULATE(a, b, c) a + b * c 

int main()
{
    int x=2;
    int y=3;
    int z=5;

    cout<<" return type stack Function Result :: "<< calculate(x+1, y+2, z) <<endl;
    cout<<" Macro Function Result :: "<< CALCULATE(x+1, y+2, z) <<endl;
}
```

```
o/p:

 return type stack Function Result :: 28
 Macro Function Result :: 16
```

Reason behind this difference is function stores copy of generated values. But, Macros directly with actual code.

Now, here in case Macro function CALCULATE

it just replace means calculation will look like below,

```
As per BODMAS rule,
x+1 + y+2 * z = 2+1 + 3+2 * 5 = 2+1 + 3+ 10 = 16
```

But, while calling calculate function,

first calculate function called and created 3 local parameters int a, int b, int c

```
and stored
    int a = x+1
    int b = y+2
    int c = z
```
From backend this is the behavior for pass by value. 

```
So, latest values are a = 2+1 = 3
b = 3+2 = 5
c = 5
```

and then while returning,
```
a + b * c = 3 + 5 * 5 = 3 + 25 = 28
```
So, be careful with macro functions specially when using logics like this.
