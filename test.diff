diff --git a/1_Basics/Macros/CMakeLists.txt b/1_Basics/Macros/CMakeLists.txt
new file mode 100644
index 0000000..1650268
--- /dev/null
+++ b/1_Basics/Macros/CMakeLists.txt
@@ -0,0 +1,28 @@
+CMAKE_MINIMUM_REQUIRED(VERSION 3.2)
+
+PROJECT(Main)
+
+# Added -save-temps flags to generate all compilation process files for each stages.
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Werror -save-temps")
+
+set(SOURCE_DIR "${PROJECT_SOURCE_DIR}/src")
+set(HEADER_DIR "${PROJECT_SOURCE_DIR}/header")
+set(LIB_SRC_DIR "${PROJECT_SOURCE_DIR}/src/DLLs/Macros")
+
+set(BIN_DIR "${PROJECT_BINARY_DIR}/bin")
+set(LIB_DIR "${PROJECT_BINARY_DIR}/lib")
+
+file(MAKE_DIRECTORY "${BIN_DIR}")
+file(MAKE_DIRECTORY "${LIB_DIR}")
+
+file(GLOB lib_source_files "${LIB_SRC_DIR}/*.cpp")
+add_library(macros SHARED "${lib_source_files}")
+set_target_properties(macros PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${LIB_DIR}")
+target_include_directories(macros PRIVATE "${HEADER_DIR}")
+
+file(GLOB source_files "${SOURCE_DIR}/*.cpp")
+add_executable(Main "${source_files}")
+set_target_properties(Main PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${BIN_DIR}")
+target_include_directories(Main PRIVATE "${HEADER_DIR}")
+
+target_link_libraries(Main macros)
diff --git a/1_Basics/Macros/Learnings.md b/1_Basics/Macros/Learnings.md
new file mode 100644
index 0000000..fd0a0d6
--- /dev/null
+++ b/1_Basics/Macros/Learnings.md
@@ -0,0 +1,200 @@
+
+Macros in C++ :-
+
+Macros is preprocessor to keep unique name for constant values.
+
+And During compilation,
+   At preprocessor stage,
+
+Total code which is written with or started with '#' will be replaced with actual value and later on
+assemebly code will be created and that code will be converted into objects files for each .cpp files.
+And at linking stage,
+All .o files and static/shared libraries will be linked
+Finally Exxecutable file will be generated by compiler.
+
+Visual Compilation Flow of cpp files
+
+Source Code (.cpp)
+        │
+        ▼
+Preprocessing (cpp) → Generates **.i** file. [Not Created by Default]**
+        │
+        ▼
+Compilation (g++ -S) → Generates **.s** (Assembly file) [Not Created by Default]**
+        │
+        ▼
+Assembly (as) → Generates **.o** (Object file) [Created]**
+        │
+        ▼
+Linker (ld) → Generates **Executable (a.out or program.exe or executable filename without extension)** [Created]**
+
+
+If you want to create all files like .i .s as well. Then you add compilation flag called
+commonly we can use {-save-temps}
+
+
+But, specifically,
+
+Preprocessor  ==>  g++ -E test.cpp -o test.i   ===> test.i [preprocessor code]
+Compilation   ==>  g++ -S test.cpp -o test.s   ===> test.s [assembly code]
+Assembly      ==>  g++ -c test.cpp -o test.o   ===> test.o [object code]
+Linking       ==>  g++ test.o -o test          ===> test   [executable file]
+
+
+So, preprocessor directly replaces each code which is started with "#" at preprocessor stage.
+
+E.g.
+```
+#define MAIN 4
+
+int main()
+{
+    int a = MAIN;
+
+    int b = MAIN;
+
+    cout<<"default value = "<<MAIN<<endl;
+
+}
+```
+if you compile above code and check .i file it will look like below,
+
+```
+int main()
+{
+    int a = 4;
+    
+    int b = 4;
+
+    cout<<"default value = "<<4<<endl;
+}
+```
+
+It is kinda similar const keyword variables. But, const keyword are not replace with actual values they will occupy specific memory for each variable. And get value from stack of that respective variable.
+
+Even you can keep macros for any kinds c++ syntax as well. But, that is correct way or use of macros.
+
+I can create even macro functions which will make code more readable.
+
+E.g.
+
+```
+#define LOG(x) cout<<x<<endl<<endl
+
+/*
+Or can be written in this way which is more understandable,
+
+#define LOG(x)           \
+{                        \
+    cout<<x<<endl<<endl; \
+}
+
+But, need to add backward slash to add each new line
+*/
+
+void Macros()
+{
+    // cout<<"Macros [START]"<<endl<<endl;
+    LOG("Macros [START]");
+
+    //cout<<"Macros [END]"<<endl<<endl;
+    LOG("Macros [END]");
+}
+```
+
+This way, code gets more readable. As i shown you have 2 ways to define your function. 
+But, in first way, you can't specify semicolon at the end of statement. Because macro will add ; as well.
+
+Uses of Macros :-
+
+- Macro names are always defined with Capital letters totally as this normal coding format for developers to understand it as Macro.
+- Macros are used nomrally for any kind of constant values. So, by macro name it can be easily understandable.
+
+
+There are some predefined macros also which you can use for debugging like,
+__FILE__   ==> which gives FILE name means your .cpp filename
+__LINE__   ==> gives line number where you written this Macro.
+__func__   ==> Gives function name
+
+```
+#define LOG(x) cout<<__FILE__<<":"<<__LINE__<<" "<<__func__<<"() "<<x<<endl<<endl
+
+void Macros()
+{
+    LOG("[START]");
+
+    LOG("[END]");
+}
+```
+
+```
+o/p :
+Macros/src/DLLs/Macros/Macros.cpp:20 Macros() [START]
+
+Macros/src/DLLs/Macros/Macros.cpp:29 Macros() [END]
+
+```
+
+One more example of macro function calculator which confuse users about calculations.
+
+
+```
+int calculate(int a, int b, int c)
+{
+    return a + b * c;
+}
+
+#define CALCULATE(a, b, c) a + b * c 
+
+int main()
+{
+    int x=2;
+    int y=3;
+    int z=5;
+
+    cout<<" return type stack Function Result :: "<< calculate(x+1, y+2, z) <<endl;
+    cout<<" Macro Function Result :: "<< CALCULATE(x+1, y+2, z) <<endl;
+}
+```
+
+```
+o/p:
+
+ return type stack Function Result :: 28
+ Macro Function Result :: 16
+```
+
+Reason behind this difference is function stores copy of generated values. But, Macros directly with actual code.
+
+Now, here in case Macro function CALCULATE
+
+it just replace means calculation will look like below,
+
+```
+As per BODMAS rule,
+x+1 + y+2 * z = 2+1 + 3+2 * 5 = 2+1 + 3+ 10 = 16
+```
+
+But, while calling calculate function,
+
+first calculate function called and created 3 local parameters int a, int b, int c
+
+```
+and stored
+    int a = x+1
+    int b = y+2
+    int c = z
+```
+From backend this is the behavior for pass by value. 
+
+```
+So, latest values are a = 2+1 = 3
+b = 3+2 = 5
+c = 5
+```
+
+and then while returning,
+```
+a + b * c = 3 + 5 * 5 = 3 + 25 = 28
+```
+So, be careful with macro functions specially when using logics like this.
diff --git a/1_Basics/Macros/header/Macros.h b/1_Basics/Macros/header/Macros.h
new file mode 100644
index 0000000..f8ec19d
--- /dev/null
+++ b/1_Basics/Macros/header/Macros.h
@@ -0,0 +1,10 @@
+#ifndef __MACROS_H__
+#define __MACROS_H__
+
+#include <iostream>
+
+using namespace std;
+
+void Macros();
+
+#endif
diff --git a/1_Basics/Macros/header/Main.h b/1_Basics/Macros/header/Main.h
new file mode 100644
index 0000000..fcf3986
--- /dev/null
+++ b/1_Basics/Macros/header/Main.h
@@ -0,0 +1,8 @@
+#ifndef __MAIN_H__
+#define __MAIN_H__
+
+#include <iostream>
+
+using namespace std;
+
+#endif
diff --git a/1_Basics/Macros/src/DLLs/Macros/Macros.cpp b/1_Basics/Macros/src/DLLs/Macros/Macros.cpp
new file mode 100644
index 0000000..eb58990
--- /dev/null
+++ b/1_Basics/Macros/src/DLLs/Macros/Macros.cpp
@@ -0,0 +1,38 @@
+#include "Macros.h"
+
+#define LOG(x) cout<<__FILE__<<":"<<__LINE__<<" "<<__func__<<"() "<<x<<endl<<endl
+
+/*
+Or can be written in this way which is more understandable,
+
+#define LOG(x)           \
+{                        \
+    cout<<x<<endl<<endl; \
+}
+
+But, need to add backward slash to add each new line
+*/
+
+int calculate(int a, int b, int c)
+{
+    return a + b * c;  // BODMAS is naturally followed
+}
+
+#define CALCULATE(a, b, c) a + b * c  // Macro with BODMAS applied
+
+void Macros()
+{
+    // cout<<"Macros [START]"<<endl<<endl;
+    LOG("[START]");
+
+    int x=2;
+    int y=3;
+    int z=5;
+
+    cout<<" return type stack Function Result :: "<< calculate(x+1, y+2, z) <<endl;
+    cout<<"{Risky While using Arthimetic operations} Macro Function Result :: "<< CALCULATE(x+1, y+2, z) <<endl;
+
+
+    //cout<<"Macros [END]"<<endl<<endl;
+    LOG("[END]");
+}
diff --git a/1_Basics/Macros/src/Main.cpp b/1_Basics/Macros/src/Main.cpp
new file mode 100644
index 0000000..f37bf7d
--- /dev/null
+++ b/1_Basics/Macros/src/Main.cpp
@@ -0,0 +1,8 @@
+#include "Main.h"
+#include "Macros.h"
+
+
+int main()
+{
+    Macros();
+}
diff --git a/5_Advanced_Topics/Templates/Learnings.txt b/5_Advanced_Topics/Templates/Learnings.md
similarity index 72%
rename from 5_Advanced_Topics/Templates/Learnings.txt
rename to 5_Advanced_Topics/Templates/Learnings.md
index 1f1f6b4..9832e03 100644
--- a/5_Advanced_Topics/Templates/Learnings.txt
+++ b/5_Advanced_Topics/Templates/Learnings.md
@@ -4,13 +4,16 @@ Templates in C++ :-
 It is a powerful tool which allows us to write generic and more readable code.
 It enable us to define functions, classes and data structures that can operate with any data type.
 
-- This avoids code duplication by keeping same function/Class/Structure for single value in multiple data type way.
+- This avoids code duplication by keeping same function/Class/Structure for single value in
+multiple data type way.
 
 E.g.
 without template
 
-1. If we want to call a print function by passing string value or sometimes int value or sometimes float value. Then it will look like below,
+1. If we want to call a print function by passing string value or sometimes int value or
+sometimes float value. Then it will look like below,
 
+```
 void Print(int value)
 {
     cout<<value<<endl;
@@ -30,19 +33,22 @@ int main()
 {
     Print(5);
     Print("Akash");
-    Print(3.5f);  ==>  'f' is given to mention value as float specifically. If f is not written then compiler things it as double and then convert it into float which may do precision loss
+    Print(3.5f);  ==>  'f' is given to mention value as float specifically. If f is not written
+    then compiler things it as double and then convert it into float which may do precision loss
 }
-
+```
 Here to call same function with different data type. I have to create 3 different functions.
 
 But, with templates,
 
-templates allows us to use single parameter with different data type of capability as per requirement.
+templates allows us to use single parameter with different data type of capability as per
+requirement.
 
 E.g.
 
-template<typename T>   ==> This is syntax to create template. Here our template name is T which will use type in function parameter,
-
+template<typename T>   ==> This is syntax to create template. Here our template name is T which
+will use type in function parameter,
+```
 void Print(T value)
 {
     cout<<value<<endl;
@@ -54,17 +60,21 @@ int main()
     Print("Akash");
     Print(3.5f);
 }
+```
+Now, because we have template T, as per parameter value template automatically defines datatype
+respective to given value.
 
-Now, because we have template T, as per parameter value template automatically defines datatype respective to given value.
-
-We can also check which typename is selected by template by using typeid(decltype(enter_variable_name)).name()
+We can also check which typename is selected by template by using
+```
+typeid(decltype(enter_variable_name)).name()
 
 For above example, cout<<"typename "<<typeid(decltype(value)).name()<<endl;
-
-One more IMP point, semicolon should not be after template declaration as it is not required.
+```
+One more IMP point, semicolon should not be present after template declaration as it is not required.
 
 if we print type for all 3 called functions it look like below,
-root@LAPTOP-AG3RGNIL:/home/anup/Git_Cpp_Learning/Templates/build# ./Main
+```
+Templates/build# ./Main
 Calling templates [START]
 
 [ Template Selected dataType:i, value:5 ]
@@ -72,11 +82,12 @@ Calling templates [START]
 [ Template Selected dataType:f, value:3.5 ]
 
 templates [END]
-
+```
+```
 i stands for integer, PKc stands for char * and f stands for float.
-
+```
 We can also mention specific typename while calling functions like below
-
+```
 Print<int>(5);
 Print<string>("Akash");
 Print<float>(3.5f);
@@ -84,14 +95,22 @@ Print<float>(3.5f);
 [ Template Selected dataType:i, value:5 ]
 [ Template Selected dataType:NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE, value:Akash ]
 [ Template Selected dataType:f, value:3.5 ]
-
+```
+```
 NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE is for string
-
-Note:- A function which has template parameter doesn't really exists for compiler. Compiler check template functions only if they called from your program. You can also check and confirm it by writing wrong syntax code inside Print then also compilation will work fine. But again it depends upon compiler. Some compiler catches syntax error from template function and some not.
-Specially, MSVC[Microsoft Visual Studio Code] won't recognise syntax errors for template functions if they are not called from your program.
-But, g++ or gcc means CLI compilers will recognise syntax errors for template functions even it they are not called from your program.
-
-One more thing, as we have initially created 3 seperate function with different type of parameters. Templates also do same thing by using compiler. As templates is just Blue Print not actual parameter.
+```
+Note:- A function which has template parameter doesn't really exists for compiler. Compiler
+check template functions only if they called from your program. You can also check and confirm
+it by writing wrong syntax code inside Print then also compilation will work fine. But again
+it depends upon compiler. Some compiler catches syntax error from template function and some not.
+Specially, MSVC[Microsoft Visual Studio Code] won't recognise syntax errors for template
+functions if they are not called from your program.
+But, g++ or gcc means CLI compilers will recognise syntax errors for template functions even
+it they are not called from your program.
+
+One more thing, as we have initially created 3 seperate function with different type of
+parameters. Templates also do same thing by using compiler. As templates is just Blue Print
+not actual parameter.
 At compile stage, if we have called
 Print(5);  Compiler create Print defination function with int parameter instead of T.
 Print(5.5f); Compiler creates one more Print defination function with float parameter instead of T.
@@ -100,7 +119,7 @@ Print(5.5f); Compiler creates one more Print defination function with float para
 We can also use templates for keeping constant values for int,float or string.
 
 E.g.
-
+```
 template<int N>
 
 class Array{
@@ -120,13 +139,13 @@ int main()
 
     cout<<a.getSize<<endl;
 }
-
-Now, here we use template for keep array size value as int N. 
+```
+Now, here we use template for keep array size value as int N.
 Now, again this class will become blueprint as we used template inside class.
 At compilation time, class with replaced value of N will be created if we create an object of that.
 Like here for Array<5> a;
 compiler creates new class,
-
+```
 class Array{
 private:
     int arr[5];
@@ -137,9 +156,9 @@ public:
         return 5;
     }
 };
-
+```
 We can also mentioned datatype of arr in template to make it fully generic like array<> of STL.
-
+```
 template<typename T, int N>
 class Array{
 private:
@@ -151,14 +170,14 @@ public:
         return 5;
     }
 }
-
+```
 Now, it is just like array<> of STL.
 
 Now, how we will use this Array,
-
+```
 like,  Array<int, 5> a;
 or Array<string, 6> users_list;
-
+```
 
 Where we should use this templates fuctionality :-
 
@@ -169,5 +188,6 @@ Where we should use this templates fuctionality :-
 
 When not to use templates :-
 
-1. At very complex code logic. Templates will make it more complex and will difficult to understand later.
+1. At very complex code logic. Templates will make it more complex and will difficult to
+understand later.
 
diff --git a/README.md b/README.md
index 3a87aa8..ff0d34b 100644
--- a/README.md
+++ b/README.md
@@ -16,6 +16,7 @@ The topics are arranged sequentially from basic to advanced.
 - `static_classes/` - Understanding static members and classes.
 - `enums_basics/` - Basics of enumerations.
 - `enums_with_logs/` - Using enums in logging mechanisms.
+- `Macros/` - Understanding Macros and Macro functions.
 - `arrow_operator/` - Using the arrow operator with pointers.
 - `sizeof_operator_usage/` - Using the `sizeof` operator.
 - `ternary_operator/` - Working with the ternary operator.
@@ -86,7 +87,7 @@ Or
 - Mastering C++ fundamentals and object-oriented programming.
 - Understanding pointers, memory management, and smart pointers.
 - Using CMake to structure and build projects efficiently.
-- Implementing advanced C++ features like operator overloading, virtual functions, and custom libraries.
+- Implementing advanced C++ features like operator overloading, virtual functions, templates and custom libraries.
 
 ---
 
